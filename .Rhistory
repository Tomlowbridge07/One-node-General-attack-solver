#Index matrix for w*'s to be put into.
IndexMatrix=matrix(nrow=B+1,ncol=b+1)
#Then for each plan change we will find what states change and what.
#Note. The last Plan is past the boundary
for(i in 1:(length(Plans)-1))
{
#Find w*
OmegaStar=FindSwappingPoint(Plans[[i]],Plans[[i+1]],CostToProgress,Lambda,PlansChangingPoints[i],PlansChangingPoints[i+1],MinTolerance,MaxSteps)
print(OmegaStar)
#Find what elements have changed in the plan
for(element in 1:length(Plans[[i]]))
{
if(Plans[[i]][element]==0 && Plans[[i+1]][element]!=0)
{
IndexMatrix[element]=OmegaStar
}
}
}
return(IndexMatrix)
}
FindIndexMatrix(0.01,MixedNormalCDF,4,3,1,0.1,1e-7,1000)
Plans
Plans[[1]]
Plans[[2]]
#This function takes in two plans and returns the swapping point omega, by use of the bisection method
FindSwappingPoint<-function(RenewInMatrix1,RenewInMatrix2,CostsToProgress,Lambda,Lowerboundary,Upperboundary,MinErrorTolerance,MaxSteps)
{
#Form the functions of g
g1=GenerateEquilbriumValue(RenewInMatrix1,CostsToProgress,Lambda)
g2=GenerateEquilbriumValue(RenewInMatrix2,CostsToProgress,Lambda)
f<-function(omega)
{
return(g1(omega)-g2(omega))
}
if(f(Lowerboundary)==0)
{
return(Lowerboundary)
}
if(f(Upperboundary)==0)
{
return(Upperboundary)
}
#We need to check the boundaries
print(f(Lowerboundary))
print(f(Upperboundary))
stopifnot(sign(f(Lowerboundary))!=sign(f(Upperboundary)))
stopifnot(f(Upperboundary)>f(Lowerboundary))
#Repeat the bisection process until tolerance or number of steps is reached
tolerance=MinErrorTolerance+1
Steps=0
a=Lowerboundary
b=Upperboundary
while(Steps<MaxSteps && tolerance>MinErrorTolerance)
{
midpoint=(a+b)/2
#evaluate mid point
midpointvalue=f(midpoint)
#if it is zero return
if(f(midpoint)==0)
{
return(midpoint)
}
#see what to replace
if(sign(f(midpoint))==sign(f(a)))
{
a<-midpoint
}
else
{
b<-midpoint
}
#update steps and tolerance
Steps=Steps+1
tolerance=(b-a)/2
}
return(midpoint)
}
#Return w* for every state. We choose to ignore later ones.
FindIndexMatrix<-function(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,MinTolerance,MaxSteps,TypeOfAttackTimeDis="CDF")
{
#We'll generate the cost to progress matrix for later use
CostToProgress=GenerateCostToProgressMatrix(B+1,b+1,Cost,Lambda,AttackTimeDistribution)
#We first solve to the boundary
SolvedOE=SolveForMultipleOmegaUntilBoundary(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,TypeOfAttackTimeDis="CDF")
#Retrive the plans
Plans=SolvedOE$Plans
PlansChangingPoints=SolvedOE$PlansChangingPoints
#Index matrix for w*'s to be put into.
IndexMatrix=matrix(nrow=B+1,ncol=b+1)
#Then for each plan change we will find what states change and what.
#Note. The last Plan is past the boundary
for(i in 1:(length(Plans)-1))
{
print(i)
#Find w*
OmegaStar=FindSwappingPoint(Plans[[i]],Plans[[i+1]],CostToProgress,Lambda,PlansChangingPoints[i],PlansChangingPoints[i+1],MinTolerance,MaxSteps)
print(OmegaStar)
#Find what elements have changed in the plan
for(element in 1:length(Plans[[i]]))
{
if(Plans[[i]][element]==0 && Plans[[i+1]][element]!=0)
{
IndexMatrix[element]=OmegaStar
}
}
}
return(IndexMatrix)
}
Plans[[2]]
#This function takes in two plans and returns the swapping point omega, by use of the bisection method
FindSwappingPoint<-function(RenewInMatrix1,RenewInMatrix2,CostsToProgress,Lambda,Lowerboundary,Upperboundary,MinErrorTolerance,MaxSteps)
{
#Form the functions of g
g1=GenerateEquilbriumValue(RenewInMatrix1,CostsToProgress,Lambda)
g2=GenerateEquilbriumValue(RenewInMatrix2,CostsToProgress,Lambda)
f<-function(omega)
{
return(g1(omega)-g2(omega))
}
if(f(Lowerboundary)==0)
{
return(Lowerboundary)
}
if(f(Upperboundary)==0)
{
return(Upperboundary)
}
#We need to check the boundaries
print(f(Lowerboundary))
print(f(Upperboundary))
stopifnot(sign(f(Lowerboundary))!=sign(f(Upperboundary)))
stopifnot(f(Upperboundary)>f(Lowerboundary))
#Repeat the bisection process until tolerance or number of steps is reached
tolerance=MinErrorTolerance+1
Steps=0
a=Lowerboundary
b=Upperboundary
while(Steps<MaxSteps && tolerance>MinErrorTolerance)
{
midpoint=(a+b)/2
#evaluate mid point
midpointvalue=f(midpoint)
#if it is zero return
if(f(midpoint)==0)
{
return(midpoint)
}
#see what to replace
if(sign(f(midpoint))==sign(f(a)))
{
a<-midpoint
}
else
{
b<-midpoint
}
#update steps and tolerance
Steps=Steps+1
tolerance=(b-a)/2
}
return(midpoint)
}
#Return w* for every state. We choose to ignore later ones.
FindIndexMatrix<-function(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,MinTolerance,MaxSteps,TypeOfAttackTimeDis="CDF")
{
#We'll generate the cost to progress matrix for later use
CostToProgress=GenerateCostToProgressMatrix(B+1,b+1,Cost,Lambda,AttackTimeDistribution)
#We first solve to the boundary
SolvedOE=SolveForMultipleOmegaUntilBoundary(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,TypeOfAttackTimeDis="CDF")
#Retrive the plans
Plans=SolvedOE$Plans
PlansChangingPoints=SolvedOE$PlansChangingPoints
#Index matrix for w*'s to be put into.
IndexMatrix=matrix(nrow=B+1,ncol=b+1)
#Then for each plan change we will find what states change and what.
#Note. The last Plan is past the boundary
for(i in 1:(length(Plans)-1))
{
print(i)
#Find w*
OmegaStar=FindSwappingPoint(Plans[[i]],Plans[[i+1]],CostToProgress,Lambda,PlansChangingPoints[i],PlansChangingPoints[i+1],MinTolerance,MaxSteps)
print(OmegaStar)
#Find what elements have changed in the plan
for(element in 1:length(Plans[[i]]))
{
if(Plans[[i]][element]==0 && Plans[[i+1]][element]!=0)
{
IndexMatrix[element]=OmegaStar
}
}
print(IndexMatrix)
}
return(IndexMatrix)
}
Plans[[2]]
FindIndexMatrix(0.01,MixedNormalCDF,4,3,1,0.1,1e-7,1000)
plans1[1]
plans1[0]
plans1
plans1
plans
plans1
#This function takes in two plans and returns the swapping point omega, by use of the bisection method
FindSwappingPoint<-function(RenewInMatrix1,RenewInMatrix2,CostsToProgress,Lambda,Lowerboundary,Upperboundary,MinErrorTolerance,MaxSteps)
{
#Form the functions of g
g1=GenerateEquilbriumValue(RenewInMatrix1,CostsToProgress,Lambda)
g2=GenerateEquilbriumValue(RenewInMatrix2,CostsToProgress,Lambda)
f<-function(omega)
{
return(g1(omega)-g2(omega))
}
if(f(Lowerboundary)==0)
{
return(Lowerboundary)
}
if(f(Upperboundary)==0)
{
return(Upperboundary)
}
#We need to check the boundaries
print(f(Lowerboundary))
print(f(Upperboundary))
stopifnot(sign(f(Lowerboundary))!=sign(f(Upperboundary)))
stopifnot(f(Upperboundary)>f(Lowerboundary))
#Repeat the bisection process until tolerance or number of steps is reached
tolerance=MinErrorTolerance+1
Steps=0
a=Lowerboundary
b=Upperboundary
while(Steps<MaxSteps && tolerance>MinErrorTolerance)
{
midpoint=(a+b)/2
#evaluate mid point
midpointvalue=f(midpoint)
#if it is zero return
if(f(midpoint)==0)
{
return(midpoint)
}
#see what to replace
if(sign(f(midpoint))==sign(f(a)))
{
a<-midpoint
}
else
{
b<-midpoint
}
#update steps and tolerance
Steps=Steps+1
tolerance=(b-a)/2
}
return(midpoint)
}
#Return w* for every state. We choose to ignore later ones.
FindIndexMatrix<-function(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,MinTolerance,MaxSteps,TypeOfAttackTimeDis="CDF")
{
#We'll generate the cost to progress matrix for later use
CostToProgress=GenerateCostToProgressMatrix(B+1,b+1,Cost,Lambda,AttackTimeDistribution)
#We first solve to the boundary
SolvedOE=SolveForMultipleOmegaUntilBoundary(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,TypeOfAttackTimeDis="CDF")
#Retrive the plans
Plans=SolvedOE$Plans
PlansChangingPoints=SolvedOE$PlansChangingPoints
#Index matrix for w*'s to be put into.
IndexMatrix=matrix(nrow=B+1,ncol=b+1)
#Then for each plan change we will find what states change and what.
#Note. The last Plan is past the boundary
for(i in 1:(length(Plans)-1))
{
print(i)
#Find w*
OmegaStar=FindSwappingPoint(Plans[[i]],Plans[[i+1]],CostToProgress,Lambda,PlansChangingPoints[i],PlansChangingPoints[i+1],MinTolerance,MaxSteps)
print(OmegaStar)
print(Plans[[i]])
print(Plans[[i+1]])
#Find what elements have changed in the plan
for(element in 1:length(Plans[[i]]))
{
if(Plans[[i]][element]==0 && Plans[[i+1]][element]!=0)
{
IndexMatrix[element]=OmegaStar
}
}
print(IndexMatrix)
}
return(IndexMatrix)
}
FindIndexMatrix(0.01,MixedNormalCDF,4,3,1,0.1,1e-7,1000)
#This function takes in two plans and returns the swapping point omega, by use of the bisection method
FindSwappingPoint<-function(RenewInMatrix1,RenewInMatrix2,CostsToProgress,Lambda,Lowerboundary,Upperboundary,MinErrorTolerance,MaxSteps)
{
#Form the functions of g
g1=GenerateEquilbriumValue(RenewInMatrix1,CostsToProgress,Lambda)
g2=GenerateEquilbriumValue(RenewInMatrix2,CostsToProgress,Lambda)
f<-function(omega)
{
return(g1(omega)-g2(omega))
}
if(f(Lowerboundary)==0)
{
return(Lowerboundary)
}
if(f(Upperboundary)==0)
{
return(Upperboundary)
}
#We need to check the boundaries
print(f(Lowerboundary))
print(f(Upperboundary))
stopifnot(sign(f(Lowerboundary))!=sign(f(Upperboundary)))
stopifnot(f(Upperboundary)>f(Lowerboundary))
#Repeat the bisection process until tolerance or number of steps is reached
tolerance=MinErrorTolerance+1
Steps=0
a=Lowerboundary
b=Upperboundary
while(Steps<MaxSteps && tolerance>MinErrorTolerance)
{
midpoint=(a+b)/2
#evaluate mid point
midpointvalue=f(midpoint)
#if it is zero return
if(f(midpoint)==0)
{
return(midpoint)
}
#see what to replace
if(sign(f(midpoint))==sign(f(a)))
{
a<-midpoint
}
else
{
b<-midpoint
}
#update steps and tolerance
Steps=Steps+1
tolerance=(b-a)/2
}
return(midpoint)
}
#Return w* for every state. We choose to ignore later ones.
FindIndexMatrix<-function(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,MinTolerance,MaxSteps,TypeOfAttackTimeDis="CDF")
{
#We'll generate the cost to progress matrix for later use
CostToProgress=GenerateCostToProgressMatrix(B+1,b+1,Cost,Lambda,AttackTimeDistribution)
#We first solve to the boundary
SolvedOE=SolveForMultipleOmegaUntilBoundary(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,TypeOfAttackTimeDis="CDF")
#Retrive the plans
Plans=SolvedOE$Plans
print(Plans)
PlansChangingPoints=SolvedOE$PlansChangingPoints
#Index matrix for w*'s to be put into.
IndexMatrix=matrix(nrow=B+1,ncol=b+1)
#Then for each plan change we will find what states change and what.
#Note. The last Plan is past the boundary
for(i in 1:(length(Plans)-1))
{
print(i)
#Find w*
OmegaStar=FindSwappingPoint(Plans[[i]],Plans[[i+1]],CostToProgress,Lambda,PlansChangingPoints[i],PlansChangingPoints[i+1],MinTolerance,MaxSteps)
print(OmegaStar)
print(Plans[[i]])
print(Plans[[i+1]])
#Find what elements have changed in the plan
for(element in 1:length(Plans[[i]]))
{
if(Plans[[i]][element]==0 && Plans[[i+1]][element]!=0)
{
IndexMatrix[element]=OmegaStar
}
}
print(IndexMatrix)
}
return(IndexMatrix)
}
FindIndexMatrix(0.01,MixedNormalCDF,4,3,1,0.1,1e-7,1000)
OE=SolveForMultipleOmegaUntilBoundary(0.01,MixedNormalCDF,4,3,1,0.1)
OE
#Similiar to above but runs until the boundary is hit
SolveForMultipleOmegaUntilBoundary<-function(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,TypeOfAttackTimeDis="CDF")
{
#For each omega we run the code, store g for that omega
OmegaIncrease=OmegaStepSize
CurrentPlan=matrix(rep(-1,(B+1)*(b+1)),nrow=B+1,ncol=b+1)
OmegaEquilibrium=matrix(nrow=2,ncol=0)
FullPlans=list()
PlanChanging=vector(length=0)
PlanChangingEqValues=vector(length=0)
Plans=list()
PlanChangingCounter=1
BoundaryHit=F
Omega=0
i=1
while(BoundaryHit==F)
{
#Run iteration solver to find plan and g
Solved=IterationSolver(Omega,AttackTimeDistribution,B,b,Cost,Lambda,TypeOfAttackTimeDis)
g=Solved$EquilibriumValue
Plan=Solved$Plan
FullPlans[[i]]=Plan
i=i+1
OmegaEquilibrium=cbind(OmegaEquilibrium,matrix(c(Omega,g),nrow=2,ncol=1))
#See if the plan changes
if(!all(CurrentPlan==Plan))
{
PlanChanging=c(PlanChanging,Omega)
Plans[[PlanChangingCounter]]=Plan
PlanChangingEqValues=c(PlanChangingEqValues,g)
PlanChangingCounter=PlanChangingCounter+1
}
CurrentPlan=Plan
#Find when it hits the boundary
if(BoundaryHit==F && g> Cost * Lambda)
{
BoundaryHitValue=Omega
BoundaryHit=T
}
Omega=Omega+OmegaIncrease
}
return(list(OmegaEquilibriumMatrix=OmegaEquilibrium,FullPlans=FullPlans,PlansChangingPoints=PlanChanging,
PlanChangingEqValues=PlanChangingEqValues,Plans=Plans,BoundaryHitValue=BoundaryHitValue))
}
OE=SolveForMultipleOmegaUntilBoundary(0.01,MixedNormalCDF,4,3,1,0.1)
OE
FindIndexMatrix(0.01,MixedNormalCDF,4,3,1,0.1,1e-7,1000)
#This function takes in two plans and returns the swapping point omega, by use of the bisection method
FindSwappingPoint<-function(RenewInMatrix1,RenewInMatrix2,CostsToProgress,Lambda,Lowerboundary,Upperboundary,MinErrorTolerance,MaxSteps)
{
#Form the functions of g
g1=GenerateEquilbriumValue(RenewInMatrix1,CostsToProgress,Lambda)
g2=GenerateEquilbriumValue(RenewInMatrix2,CostsToProgress,Lambda)
f<-function(omega)
{
return(g1(omega)-g2(omega))
}
if(f(Lowerboundary)==0)
{
return(Lowerboundary)
}
if(f(Upperboundary)==0)
{
return(Upperboundary)
}
#We need to check the boundaries
print(f(Lowerboundary))
print(f(Upperboundary))
stopifnot(sign(f(Lowerboundary))!=sign(f(Upperboundary)))
stopifnot(f(Upperboundary)>f(Lowerboundary))
#Repeat the bisection process until tolerance or number of steps is reached
tolerance=MinErrorTolerance+1
Steps=0
a=Lowerboundary
b=Upperboundary
while(Steps<MaxSteps && tolerance>MinErrorTolerance)
{
midpoint=(a+b)/2
#evaluate mid point
midpointvalue=f(midpoint)
#if it is zero return
if(f(midpoint)==0)
{
return(midpoint)
}
#see what to replace
if(sign(f(midpoint))==sign(f(a)))
{
a<-midpoint
}
else
{
b<-midpoint
}
#update steps and tolerance
Steps=Steps+1
tolerance=(b-a)/2
}
return(midpoint)
}
#Return w* for every state. We choose to ignore later ones.
FindIndexMatrix<-function(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,MinTolerance,MaxSteps,TypeOfAttackTimeDis="CDF")
{
#We'll generate the cost to progress matrix for later use
CostToProgress=GenerateCostToProgressMatrix(B+1,b+1,Cost,Lambda,AttackTimeDistribution)
#We first solve to the boundary
SolvedOE=SolveForMultipleOmegaUntilBoundary(OmegaStepSize,AttackTimeDistribution,B,b,Cost,Lambda,TypeOfAttackTimeDis="CDF")
#Retrive the plans
Plans=SolvedOE$Plans
PlansChangingPoints=SolvedOE$PlansChangingPoints
#Index matrix for w*'s to be put into.
IndexMatrix=matrix(nrow=B+1,ncol=b+1)
#Then for each plan change we will find what states change and what.
#Note. The last Plan is past the boundary
for(i in 1:(length(Plans)-1))
{
#Find w*
OmegaStar=FindSwappingPoint(Plans[[i]],Plans[[i+1]],CostToProgress,Lambda,PlansChangingPoints[i],PlansChangingPoints[i+1],MinTolerance,MaxSteps)
print(OmegaStar)
#Find what elements have changed in the plan
for(element in 1:length(Plans[[i]]))
{
if(Plans[[i]][element]==0 && Plans[[i+1]][element]!=0)
{
IndexMatrix[element]=OmegaStar
}
}
}
return(IndexMatrix)
}
FindIndexMatrix(0.01,MixedNormalCDF,4,3,1,0.1,1e-7,1000)
